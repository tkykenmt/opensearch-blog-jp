---
title: "[翻訳] star-tree インデックスの力：OpenSearch の集計を強化する"
emoji: "🙆‍♀️"
type: "tech"
topics:
  - "opensearch"
published: true
published_at: "2025-05-13 14:36"
---

本記事は OpenSearch Project Blog "[The power of star-tree indexes: Supercharging OpenSearch aggregations](https://opensearch.org/blog/the-power-of-star-tree-indexes-supercharging-opensearch-aggregations/)" の日本語訳です。

OpenSearch における集計は、リアルタイムのデータ分析と可視化を可能にする重要な役割を果たしています。これらは OpenSearch Dashboards で広く使用され、インタラクティブなチャートやダッシュボードを作成し、大量のデータに関する洞察を提供します。しかし、データが増加するにつれて、集計のパフォーマンスが低下することがあります。そこで新しい **star-tree インデックス** の出番です。

star-tree インデックスは OpenSearch 2.18 で導入された実験的機能で、インデックス作成時に集計を事前計算します。これにより、特に大規模なデータセットや複雑な集計において、クエリのレイテンシーが大幅に削減されます。ログデータに対するダッシュボードの実行や、何百万ものレコードに対するメトリクスの計算など、star-tree インデックスを使用すれば、クエリを変更することなく、より高速かつ予測可能な方法でクエリを実行できます。

このブログ記事では、star-tree インデックスとは何か、どのように機能するのか、そしてどのように集計を高速化するために使用できるのかを学びます。

## OpenSearch における集計

OpenSearch では、以下のようないくつかのタイプの集計が提供されています：

* **メトリック集計**：数値フィールドに対する合計、最小値、最大値、平均値などのメトリクスを計算します。
* **バケット集計**：定義された基準に基づいてクエリ結果をグループ化します。例えば、日付ヒストグラムを使用して時間間隔でグループ化します。

しかし、標準的なクエリと比較して、集計にはパフォーマンス上の課題が生じる可能性があります：

* **スケーラビリティ**：一致するドキュメント数が増えるとクエリのレイテンシーが増加します。
* **リソース消費**：集計には、より多くの CPU、メモリ、ディスク使用量が必要です。

例えば、HTTP ステータスコードでグループ化された平均値や合計などのメトリック集計を計算してアプリケーションログを分析するタスクを考えてみましょう。

次の表は、高頻度のステータスコードと低頻度のステータスコードで集計する場合のクエリレイテンシーを比較しています。

| クエリ | ドキュメント数 | レイテンシー (ミリ秒)  |
|------|------------|-----------------|
| ステータス = `200` のメトリック集計 | 200,000,000 | 4200 |
| ステータス = `400` のメトリック集計 | 3,000 | 5 |

この場合、ステータス コード `200` (OK) はログに非常に頻繁に出現しますが、ステータス コード `400` (Bad Request) は比較的まれです。`200` のような高頻度の値に対する集計では、はるかに多くのドキュメントをスキャンする必要があり、レイテンシーが大幅に高くなります。対照的に、`400` のような低頻度の値に対する集計では、より少ないドキュメントが関与し、はるかに速く完了します。

star-tree インデックスは、スケールが大きくなっても、このレイテンシーを削減するように設計されています。

## star-tree インデックスとは？

Apache Pinot にインスパイアされた star-tree インデックスは、集計を高速化するために設計された OpenSearch 初のマルチフィールドインデックスです。インデックス作成中に、star-tree インデックスは定義されたディメンションのすべての組み合わせに対して、設定されたメトリクスの集計を事前計算します。

次の図は、star-tree インデックスの高レベル アーキテクチャを示しています。

![star-tree インデックスの構造](https://storage.googleapis.com/zenn-user-upload/f4c2211c4d38-20250513.png)

このツリーは、`status` や `Day` などのディメンション値に基づいて階層的に構成されています。ルートノードからリーフへの各パスは、ディメンション値の一意の組み合わせを表します。リーフノードには、そのディメンションの組み合わせに一致するドキュメントの集計されたメトリクス (`Avg(size)` や `Count(reqs)` など) が含まれています。**スター ノード (`*`) ** は、特定のディメンションのすべての値にわたる集計値を表すために使用され、クエリが不要なブランチをスキップできるようにします。**子ノード** は、ドキュメント数が設定可能なしきい値 (`maxLeafDocs`) を超える場合にのみ作成されます。

図の例は、クエリがツリーをどのように走査するかを示しています：`status = 200` かつ `Day = 11` の平均サイズを求めるクエリは特定のパス (青い矢印で示されています) をたどりますが、`Day = 12` (ステータスに関係なく) の平均サイズを求めるクエリはスター ノードを使用して `status` ディメンションを完全にスキップします。

内部的には、star-tree インデックスは次のコンポーネントで構成されています：

* 効率的な走査のために一意のディメンション値をツリーノードに整理する **スターツリー**。
* 設定されたディメンションの事前集計された結果を格納する **列指向のドキュメント値**。

詳細な技術情報については、[Star-tree インデックス構造](https://docs.opensearch.org/docs/latest/search-plugins/star-tree-index/#star-tree-index-structure)をご覧ください。

## star-tree インデックスを使用する利点

star-tree インデックスは、スケールの大きい高性能分析に適した以下の利点を提供します。

### 予測可能なレイテンシー

従来、OpenSearch における集計クエリのレイテンシーは、一致するドキュメント数に応じて増加していました。star-tree インデックスは集計結果を事前計算することで、より高速で予測可能なクエリ レイテンシーを提供します。次の表に示すとおりです。

| クエリ | ドキュメント数 | 通常クエリのレイテンシー | star-tree クエリのレイテンシー |
|------|------------|-----------------|----------------------|
| ステータス = 200 の Avg(duration) | 2億 | 4.2秒 | 6.3ミリ秒 |
| ステータス = 400 の Avg(duration) | 3,000 | 5ミリ秒 | 6.5ミリ秒 |

### 複数集計のサポート

従来、異なるフィールドに対する複数の集計を含むクエリを実行する場合、各集計の各フィールドが個別に処理され、レイテンシーが増加していました。対照的に、star-tree インデックスはネイティブなマルチフィールドサポートを提供し、これらのシナリオでの効率が大幅に向上します。star-tree インデックスは複数の集計にまたがるクエリを前処理し、star-tree の繰り返し走査の必要性を排除し、全体的なパフォーマンスを向上させます。

### 複雑な集計のスループット向上

大規模なデータセットに対するサブ集計を含む日付ヒストグラムのようなリソース集約型の操作では、star-tree インデックスはレイテンシーを大幅に削減し、スループットを向上させます。次の表に示すとおりです。

| クエリ | ドキュメント数 | 従来のクエリレイテンシー | star-tree クエリレイテンシー (N = 10,000) | 従来のクエリスループット | star-tree クエリスループット |
|------|------------|-----------------|----------------------|-----------------|---------------------|
| チップ金額の合計に関する年次日付ヒストグラム (乗客数 = 1)  | 1億2千万 | 13秒 | 94ミリ秒 | 0.08 | 2.01 |
| 年次日付ヒストグラム (乗客数 = 1–2)  | 1億4千万 | 15秒 | 114ミリ秒 | 0.07 | 2.01 |
| 年次日付ヒストグラム (乗客数 = 1–5)  | 1億6千万 | 17秒 | 160ミリ秒 | 0.06 | 2.01 |

### 設定可能性

star-tree インデックスには、ストレージオーバーヘッドとクエリパフォーマンスのバランスを取るための様々な[設定オプション](https://docs.opensearch.org/docs/latest/field-types/supported-field-types/star-tree/#star-tree-index-configuration-options)が含まれています。例えば、`max_leaf_docs` パラメータは、各 star-tree リーフに含まれるドキュメントの数を制御します。`max_leaf_docs` の値が高いほど、ストレージ効率は向上しますが、クエリレイテンシーが増加します。

次の表は、従来のクエリと異なる `max_leaf_docs` 値 (N) を持つ star-tree クエリの間のパフォーマンスの違いを示しています。

| クエリ | ドキュメント数 | 従来のクエリレイテンシー | star-tree クエリレイテンシー (N = 100) | star-tree レイテンシー (N = 10,000) |
|------|------------|-----------------|----------------------|------------------------|
| ステータス = `200` のメトリック集計 | 2億 | 4.2秒 | 2.5ミリ秒 | 6.3ミリ秒 |
| ステータス = `400` のメトリック集計 | 3,000 | 5ミリ秒 | 2.7ミリ秒 | 8.5ミリ秒 |

### リアルタイム互換性

インデックスロールアップやトランスフォームなどの機能は事前集計されたビューを提供しますが、リアルタイムデータでは動作せず、インデックス作成のパフォーマンスを低下させる可能性があります。対照的に、star-tree インデックスは最小限のインデックス作成オーバーヘッドでリアルタイムに動作します。クエリには変更が必要ありません。エンジンは自動的に適格なクエリを検出し、star-tree インデックスにルーティングします。

## 制限事項

star-tree インデックスは大幅なパフォーマンス上の利点を提供しますが、現在は以下の制限があります。

* star-tree インデックスは現在、不変のデータセットにのみ適しています。ドキュメントの変更 (更新または削除) は star-tree インデックスに反映されません。
* star-tree インデックスは refresh/flush/merge 操作中に作成され、書き込みスループットに影響を与える可能性があります。ベンチマークデータはまもなく公開される予定です。
* インデックスに star-tree が作成されると、そのインデックスから削除することはできません。star-tree 機能を無効にする必要がある場合は、star-tree マッピング設定なしで新しいインデックスにすべてのデータを再インデックスする必要があります。ただし、`indices.composite_index.star_tree.enabled` を `false` に設定することで、star-tree 検索ではなく従来の検索を使用してインデックスを検索することができます。

詳細については、[制限事項](https://docs.opensearch.org/docs/latest/search-plugins/star-tree-index/#limitations)をご覧ください。

## star-tree インデックスの使用方法

star-tree インデックスを使用するには、インデックス作成時に [star-tree マッピング](https://docs.opensearch.org/docs/latest/field-types/supported-field-types/star-tree/#star-tree-index-mappings) を定義します。マッピングは、最適化したい集計のディメンションとメトリクスを反映する必要があります。

star-tree インデックスを使用する際は、以下の詳細に注意してください。

* クエリ構文やパラメータに変更は必要ありません。
* OpenSearch 2.19 の時点では、特定の[集計タイプ](https://docs.opensearch.org/docs/latest/search-plugins/star-tree-index/#supported-queries-and-aggregations)のみがサポートされています。
* OpenSearch は自動的に適格なクエリを識別し、リアルタイムで star-tree インデックスを使用して最適化します。
* インデックス作成時に設定すると、star-tree インデックスは追加のメンテナンスや変更を必要としません。

## 結論

star-tree インデックスは OpenSearch の集計パフォーマンスを大幅に向上させます。スケールが大きくなっても一貫した低レイテンシーの結果を提供し、クエリ側の変更は必要ありません。

将来的には、ブール クエリ、日付範囲クエリ、ネストされた集計、および用語集計を含む追加の集計およびクエリタイプをサポートする予定です。採用が進むにつれて、star-tree インデックスは OpenSearch におけるリアルタイム分析の重要なコンポーネントになる見込みです。この機能の進捗状況を追跡するには、[この Issue](https://github.com/opensearch-project/OpenSearch/issues/15257) をご覧ください。

## 補足
OpenSearch 3.0.0 において、追加で以下の機能がサポートされました。

* keyword および Numeric terms aggregation ([#17165](https://github.com/opensearch-project/OpenSearch/pull/17165))
* Numericrange aggregation [#17273](https://github.com/opensearch-project/OpenSearch/pull/17273)
* Unsigned long のサポート ([#17275](https://github.com/opensearch-project/OpenSearch/pull/17275))
* aggregations における Boolean Queries のサポート ([#17941](https://github.com/opensearch-project/OpenSearch/pull/17941))
