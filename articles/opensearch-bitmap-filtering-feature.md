---
title: "[翻訳] OpenSearch のビットマップフィルタリングによる効率的な大規模フィルタリング"
emoji: "🗺️"
type: "tech"
topics: ["opensearch", "performance", "filtering", "bitmap"]
published: true
published_at: 2025-02-25
publication_name: "opensearch"
---

:::message
本記事は [OpenSearch Project Blog](https://opensearch.org/blog/) に投稿された以下の記事を日本語に翻訳したものです。
:::

https://opensearch.org/blog/introduce-bitmap-filtering-feature/

OpenSearch は、大規模なデータセットを効率的に検索およびフィルタリングできる強力なオープンソースの検索・分析エンジンです。一般的な検索パターンとして、フィールドが大きなセット内のいずれかの値と一致するかどうかに基づいてドキュメントをフィルタリングすることがあります。既存の `terms` クエリは小さなセットではうまく機能しますが、数千から数百万の用語を処理する際にはパフォーマンスが大幅に低下します。

OpenSearch 2.17 では、この問題に対処するために*ビットマップフィルタリング*を導入し、大規模なフィルタリング操作をより効率的に処理する方法を提供しました。OpenSearch 2.19 では、小さなクエリのパフォーマンスを向上させ、全体的な効率を最適化する新しいインデックスベースのビットマップクエリでこの機能をさらに強化しています。

## 大規模フィルタリングの課題

多くのアプリケーションでは、数値識別子が大きなセット内のいずれかの値と一致するかどうかをチェックしてドキュメントをフィルタリングする必要があります。以下の例を考えてみましょう。

- EC サイトプラットフォームが、顧客のデジタルライブラリ内のアイテムのみを表示するために商品カタログをフィルタリングする (商品 ID を数千の購入済みアイテムのリストと照合)
- 書店チェーンが特定の店舗のすべての書籍を検索する (書籍 ID を数千の ISBN のリストと照合)

大きな識別子セットに対して `terms` クエリを使用すると、以下の問題が発生する可能性があります。

- クエリサイズの増加に伴うパフォーマンスの低下
- 高いメモリと CPU 消費によるスケーラビリティの課題
- 広範なフィルターリストの送信によるネットワークオーバーヘッド

これらの制限は、特に大規模なデータセットと高トラフィックのワークロードにおいて、パフォーマンスとスケーラビリティの両方に悪影響を与えます。

## ビットマップフィルタリング: 最適化されたアプローチ

ビットマップフィルタリングは、商品 ID や ISBN 番号などの整数セットでフィルタリングする際のクエリパフォーマンスとスケーラビリティを向上させます。整数セットを処理するための効率的なデータ構造である [RoaringBitmap](https://github.com/RoaringBitmap/RoaringBitmap) を使用します。

- RoaringBitmap は、データ特性に基づいて最も効率的な内部表現を自動的に選択します。スパースな整数セットに対して優れた圧縮を提供しながら、高速なルックアップ速度を維持します。
- セット操作 (例: 交差や和集合) は、OpenSearch にクエリを送信する前に RoaringBitmap ライブラリを使用して効率的に計算できます。

## OpenSearch がビットマップフィルタリングを実装する方法

OpenSearch はビットマップフィルタリングをクエリインフラストラクチャにシームレスに統合しています。

- `terms` クエリの新しい `value_type` パラメータにより、Base64 エンコードされた Roaring ビットマップを使用してフィルターリストを指定できます。
- `terms` ルックアップが強化され、`_source` 全体からではなく、保存されたフィールドから値を取得するようになりました。

## 例: 顧客の購入済み商品のフィルタリング

100 万の商品と 10 万の顧客を持つ EC マーケットプレイスを運営しているとします。各顧客には購入した商品を含むデジタルライブラリがあります。各顧客の商品所有権を表すビットマップを維持しています。ビットマップフィルタリングを使用すると、特定の顧客が所有する商品を以下のように効率的に取得できます。

```json
POST products/_search
{
  "query": {
    "terms": {
      "product_id": {
        "index": "customers",
        "id": "customer123",
        "path": "customer_filter",
        "store": true
      },
      "value_type": "bitmap"
    }
  }
}
```

この例では、ビットマップフィルターが `products` インデックスの `product_id` フィールドに適用され、特定の顧客が所有する商品を取得します。ビットマップフィルターデータは `customers` インデックスのドキュメント ID `customer123` の `customer_filter` フィールドに保存されています。このバイナリフィールドは高速な取得と効率的な処理のために最適化されています。クエリ実行中、ビットマップフィルターはメモリにロードされ、フィルタリング操作に適用されます。

前の例のように `terms` ルックアップを使用する代わりに、クエリでビットマップを直接提供することもできます。

```json
POST products/_search
{
  "query": {
    "terms": {
      "product_id": ["<base64-encoded-bitmap>"],
      "value_type": "bitmap"
    }
  }
}
```

この場合、ビットマップはクエリに含める前に Base64 エンコードする必要があります。このアプローチは、事前計算されたビットマップがある場合や、OpenSearch にクエリを送信する前にクライアント側でビットマップ操作を実行する必要がある場合に便利です。

## ビットマップフィルタリングの主な利点

ビットマップフィルタリングは OpenSearch の既存のクエリインフラストラクチャとシームレスに統合されます。

- `value_type: "bitmap"` パラメータにより、`terms` クエリでビットマップフィルターを指定できます。
- 強化された `terms` ルックアップにより、保存されたビットマップフィルターを効率的に取得できます。
- ビットマップフィルターを Boolean クエリで他のクエリタイプと組み合わせることができ、大規模フィルタリングのための柔軟なツールとなります。

これらの強化により、既存の OpenSearch クエリへの最小限の変更でビットマップフィルタリングを採用でき、大規模フィルタリング操作で大幅なパフォーマンス向上を得ることができます。

## パフォーマンスベンチマーク

1 億ドキュメントを含むインデックスでパフォーマンステストを実施し、100 から 1,000 万のランダム ID にわたるフィルターサイズで異なるフィルタリングアプローチを比較しました。

以下のアプローチを比較しました。

- ドキュメント値のみのフィールドでの ID リストを使用したクエリ (標準 `terms` クエリ) (OpenSearch 2.17)
- インデックス付きフィールドでの ID リストを使用したクエリ (標準 `terms` クエリ) (OpenSearch 2.17)
- ドキュメント値のみのフィールドでのビットマップフィルタリングを使用したクエリ (OpenSearch 2.17)
- インデックス付きフィールドでのビットマップフィルタリングを使用したクエリ (OpenSearch 2.19)

小さなフィルターサイズ (最大 10 万 ID) では、標準アプローチとビットマップアプローチは同様のパフォーマンスを示しました。しかし、より大きなフィルターサイズでは標準メソッドが急速に劣化する一方、ビットマップフィルタリングは数百万の ID でも安定したパフォーマンスを維持しました。

### 最適化されたビットマップフィルタリングの比較

OpenSearch 2.19 ではインデックスベースのビットマップクエリが導入されました。ビットマップクエリは、Boolean クエリで他のフィルターと一緒に使用される場合、クエリコンテキストとコスト推定に基づいて最も効率的な実行戦略 (インデックスまたはドキュメント値クエリ) を自動的に選択できるようになりました。元のドキュメント値ベースのビットマップ実装と比較して、新しい実装はベンチマーク実験で顕著な改善を提供します。

- 小さなフィルターサイズで **1,000 倍の速度向上**
- 数百万の ID でも**一貫して低いクエリ時間**
- すべてのフィルターサイズで**安定したパフォーマンス**

ビットマップフィルタリングは高速であるだけでなく、スペース効率も優れています。1,000 万 ID を含むフィルターは、ビットマップとしてエンコードすると **16 MB** のストレージしか必要としませんが、生の ID リストでは **360 MB** 必要です。このコンパクトな表現により、ネットワーク転送時間、ディスク I/O、メモリ使用量が削減されます。

## まとめ

OpenSearch のビットマップフィルタリングは、大きな数値識別子セット (数千から数百万) を使用してドキュメントをフィルタリングする効率的な方法を提供します。`terms` クエリと `terms` ルックアップに統合されており、以下のようなシナリオで特に有用です。

- デジタルコンテンツプラットフォームがユーザーの権限に基づいて大規模なドキュメントコレクションをフィルタリングする
- EC プラットフォームが商品 ID を顧客ライブラリと照合する

ビットマップフィルタリングと標準の `terms` クエリのどちらがニーズに最適かを判断するには、[パフォーマンスベンチマーク](https://opensearch.org/blog/introduce-bitmap-filtering-feature/#performance-benchmarks)を参照してください。大規模アプリケーションでビットマップフィルタリングを使用している場合は、今後の改善に役立てるため、[OpenSearch フォーラム](https://forum.opensearch.org/)でフィードバックをお寄せください。
