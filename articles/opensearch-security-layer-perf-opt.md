---
title: "[翻訳] OpenSearch セキュリティレイヤーのパフォーマンス最適化"
emoji: "🔐"
type: "tech"
topics: ["opensearch", "security", "performance", "java"]
published: true
publication_name: "opensearch"
published_at: 2025-08-14
---

:::message
本記事は [OpenSearch Project Blog](https://opensearch.org/blog/) に投稿された以下の記事を日本語に翻訳したものです。
:::

https://opensearch.org/blog/performance-optimizations-for-the-opensearch-security-layer/

OpenSearch のパフォーマンス最適化について議論する際、通常は実際のデータ処理に焦点を当てます。クエリの実行時間を短縮したり、インデックス作成のスループットを向上させたりするためのアルゴリズムやデータ構造を検討します。

しかし、OpenSearch クラスターで実行される他のプロセスは、それほど目立たないものの、パフォーマンスに大きな影響を与える可能性があります。その中でも特に重要なのがセキュリティレイヤーです。セキュリティレイヤーは、認証、認可、およびアクセス制御の適用を担当しています。この記事で説明するように、利用可能な権限を導出するためのセキュリティロールの評価は、驚くほど複雑で時間がかかることがあります。

過去 1 年間、私たちは OpenSearch セキュリティレイヤーに対するさまざまな最適化に取り組んできました。これらは OpenSearch 2.19、OpenSearch 3.0、OpenSearch 3.1 で段階的にリリースされています。さらなる改善も進行中です。

## 概要

この記事では、以下の最適化について説明します。

- **最適化された権限評価**: 高効率なハッシュテーブルベースのロジックを使用し、インデックス数の増加に伴うパフォーマンス低下を軽減します。これは 300 以上のインデックスを持つクラスターで特に重要です。
- **最適化されたドキュメントレベルおよびフィールドレベルセキュリティ**: 権限評価をシャードレベルに移動することで、内部クラスター通信トラフィックを削減します。これはユーザーにドキュメントレベルセキュリティの制限が適用されている場合に関連します。
- **追加のユーザーオブジェクト最適化**: 全般的に高いパフォーマンス向上を提供します。多くのロールと属性を持つユーザーは、特に顕著な改善を実感できるでしょう。

OpenSearch 3.1 にアップグレードすることで、これらすべての最適化の恩恵を受けることができます。

## 以前のバージョンの OpenSearch におけるパフォーマンス要因

まず、パフォーマンス改善前の初期状態を見てみましょう。OpenSearch セキュリティレイヤーの驚くべきパフォーマンス特性の 1 つは、パフォーマンスがセキュリティ設定の複雑さ (例: ロール数) だけでなく、クラスター内のインデックス数にも依存していたことです。

OpenSearch 2.18 でベンチマークを実行し、クラスター内のインデックス数とロール数がパフォーマンスに与える影響を特定しました。さまざまなインデックス数 (10、30、100、300、1,000、3,000、10,000 インデックス) を持つクラスターで、バルクインデックス操作と検索操作をテストしました。さらに、フル権限を持つユーザー、単一の制限付きセキュリティロールを持つユーザー、20 のセキュリティロールを持つユーザー、40 のセキュリティロールを持つユーザーでテストしました。

最初のグラフを見てみましょう。これは 1 リクエストあたり 10 バルクアイテムのバルクインデックス操作のベンチマーク結果を示しています。横軸はクラスター内のインデックス数を表し、縦軸は 1 秒あたりのドキュメント数で測定されたスループットを表します。ロール設定の複雑さは線の色で示されています。緑はフル権限を持つユーザーを表し、黄色は制限付き権限を持つユーザーを表します。黄色が濃いほど、ユーザーに割り当てられているロールが多くなります。青い線は superadmin TLS 証明書を使用して実行されたテストを表しています。この証明書を使用すると、セキュリティレイヤーのほとんどがバイパスされます。したがって、これは理論的に可能なスループットの上限として解釈できます。

![バルクインデックス操作のベンチマーク結果](/images/opensearch-security-layer-perf-opt/benchmark-bulk-baseline.svg)

約 100 インデックスを超えるとパフォーマンスが低下し始めることがわかります。300 インデックスのクラスターでは、ユーザーは 100 インデックスのクラスターで達成したスループットの 82% しか達成できません。これはクラスター内のインデックス数にのみ関連しており、バルクインデックスリクエストで参照されるインデックス数とは無関係であることに注意してください。1,000 インデックスのクラスターでは、元のスループットの 57% に低下します。インデックス数が増加するにつれて、スループットの二次関数的な低下が観察されます。

ロール数の影響もグラフで確認できます。1 つのロールを持つ制限付きユーザーと無制限ユーザーを比較すると、制限付きユーザーは無制限ユーザーのスループットの約 90% を達成していることがわかります。20 のロールを持つユーザーは、単一ロールユーザーのスループットの約 88% を達成しています。

「300 や 3,000 のインデックスを持つクラスターは現実的なのか?」と疑問に思うかもしれません。300 インデックスのクラスターは簡単に達成できます。毎日新しいインデックスを作成するようにインジェストを設定することは一般的な方法です。したがって、追加のインデックスライフサイクル管理がなければ、1 年未満で単一のアプリケーションに 300 のインデックスが存在することになります。3,000 インデックスのクラスターはより稀ですが、「実際の環境」でも観察されることがあります。それ以上のインデックスを持つクラスターは非常に稀であり、これはおそらくパフォーマンスの問題の可能性があるためです。

パフォーマンスとクラスター内のインデックス数のバランスは難しい場合があります。最初は、各クラスターは少数のインデックスしか持たず、適切なパフォーマンスが得られます。時間が経つにつれて、クラスターにはますます多くのインデックスが蓄積され、徐々にパフォーマンスが低下します。

検索操作のベンチマーク結果も同様です。このグラフには追加の線があります。紫の線は、ドキュメントレベルセキュリティの制限を課すロールを持つユーザーのスループットを表しています。ドキュメントレベルセキュリティは読み取り操作でのみ利用可能なため、ここでのみ考慮できます。

これらのベンチマークから、以前のバージョンの OpenSearch では、最大 300 インデックスのクラスターが妥当であることがわかります。しかし、クラスターにさらにインデックスを追加すると、パフォーマンスに大きな影響を与えます。

## 最適化された権限評価

これらのパフォーマンス問題に対処するため、[最適化された権限評価プロジェクト](https://github.com/opensearch-project/security/issues/3870)を開始しました。権限評価を担当するコードを分析したところ、ロール、権限、インデックスに対するかなり多くのネストされたループが使用されていることが明らかになりました。数学的に言えば、コードは *O(n²)* の計算量クラスにあり、*n* はインデックス数です。

**注**: *O(n²) 計算量クラス* という表現は、アルゴリズムの計算量について推論するために使用できる [Big O 記法](https://en.wikipedia.org/wiki/Big_O_notation)に由来します。大まかに言えば、*O(1)* は優れており、*O(log n)* は良好、*O(n)* は普通、*O(n²)* は悪く、それ以上は許容できないと言えます。

私たちの目標は、より良い計算量クラスを達成する新しい権限評価コードを構築することでした。理想的には *O(1)*、つまりインデックス数などの要因に依存しないアルゴリズムです。

最適なパフォーマンスを達成するために、最適化された権限評価の中核となる新しいデータ構造を設計しました。データ構造を設計する際、最適な結果を確保するためにいくつかの基本的な戦略を適用しました。

- **高速なデータ構造の使用**: ハッシュテーブルは、償却 *O(1)* の計算量で最適なパフォーマンスを提供します。
- **非正規化データ構造の使用**: ロール設定では、インデックスとアクションに対するパターン式やグループ化を使用して、権限を非常にコンパクトに指定できます。しかし、このデータ構造で直接権限評価を実行することはあまり効率的ではありません。このような場合、最大のパフォーマンスを達成するために非正規化が使用されます。インデックスとアクションのパターンを具体的なアクションに解決し、インデックス/アクションのグループ化を「展開」することで、ロール設定を大きな非正規化データ構造に拡張できます。
- **できるだけ少ないループの使用**: 理想的なパフォーマンスは、ループなしで権限評価を実行できれば達成され、真の *O(1)* 計算量になります。実際には、ループを完全に回避することはほとんど不可能ですが、最小化することは常に良いアイデアです。ループを回避できない場合は、ループ内で費やされる反復の総数を最小化することがベストプラクティスです。
- **問題空間をできるだけ早く縮小**: 最も選択的な基準を特定し、最初に適用します。これにより、必要な反復回数を減らし、ハッシュテーブルのパフォーマンスを向上させることができます。

最後に、非正規化の欠点の 1 つは、大量のデータを作成する可能性があることです。データ量を管理可能に保つために、データ量を妥当な程度に削減する技術を再び使用する必要がありました。

詳細に興味がある場合は、実際のコードは [`ActionPrivileges`](https://github.com/opensearch-project/security/blob/3c635c9f64ec58be206d9c43a865bd8cfa423fa1/src/main/java/org/opensearch/security/privileges/ActionPrivileges.java) クラスで見つけることができます。[実装の詳細に関するブログ記事](https://eliatra.com/blog/performance-improvements-for-the-access-control-layer-of-opensearch-2/)も参照できます。

新しいコードのベンチマークを見てみましょう。次のグラフは、古いコード (破線で表示) と新しいコード (実線で表示) のバルクインデックススループットを比較しています。

![最適化後のバルクインデックス操作のベンチマーク結果](/images/opensearch-security-layer-perf-opt/benchmark-bulk-optimized.svg)

大幅なパフォーマンス向上が確認できます。特に 2 つの特性が際立っています。

- 実線はほぼ直線であり、クラスター内のインデックス数に相関する大きな変化を示していません。これは、新しい実装で使用されているデータ構造の実行時特性に対応しているため、予想通りです。3,000 インデックスから始まるわずかなパフォーマンス低下がまだあります。最大 100,000 インデックスで[権限評価コードのマイクロベンチマーク](https://github.com/opensearch-project/security/pull/4380#issuecomment-2208603824)も追加で実行しました。これらのマイクロベンチマークでは、このパフォーマンス動作は観察されませんでした。したがって、この低下は別のコードに起因するものであり、記事の最後で詳しく説明します。
- パフォーマンスは大幅に向上しています。最大 100 インデックスのクラスターでは、これは非自明なロール設定を持つユーザーにのみ顕著になります。100 を超えるインデックスを持つクラスターでは、すべてのユーザーに顕著になります。300 インデックスのクラスターの場合、フル権限を持つユーザー (最も単純なロール設定を持つユーザー) は 27% のスループット向上を達成しています。1,000 インデックスのクラスターでは、79% の向上が達成されており、これは非常に素晴らしい結果です!

最適化された権限評価コードは OpenSearch 2.19 でリリースされたため、OpenSearch のバージョンを最新に保っていれば、すでにより良いパフォーマンスを得ています。

## ドキュメントレベルおよびフィールドレベルセキュリティの最適化された権限評価

これまで説明した最適化は、アクションアクセス制御、つまり「ユーザー X はアクション Y を (インデックス Z で) 実行することを許可されているか?」という質問への回答のみを対象としています。しかし、ドキュメントレベルセキュリティとフィールドレベルセキュリティは、より細かいアクセス制御を提供します。これらには、別の権限評価とアクセス制御の実装が必要です。

2 番目のステップとして、アクション権限用に開発した技術をドキュメントレベルおよびフィールドレベルセキュリティにも適用しました。さらに、ドキュメントレベルおよびフィールドレベルセキュリティの権限評価がより分散的に実行されるように、アクセス制御の実装を変更しました。

元々、ドキュメントレベルおよびフィールドレベルセキュリティの権限評価は、それぞれのリクエストを受信したノードで集中的に実行されていました。評価された権限は、シャードからドキュメントを取得するさまざまなクラスターノードに渡されていました。このアプローチは、権限評価が検索リクエストごとに 1 回だけ実行されればよいという点で有利でした。しかし、これには欠点もありました。結果のデータ構造が巨大になる可能性があり、これもまた大きなパフォーマンスペナルティを招く可能性がありました。

現在、ドキュメントレベルおよびフィールドレベルセキュリティの権限評価をシャードレベルに移動し、可能な限り分散化しました。もちろん、これは単一の検索リクエストに対して権限がより頻繁に評価されることを意味します。しかし、最適化された権限評価コードのおかげで、これは関連する要因ではありません。

ベンチマークは、このアプローチを使用した場合に大幅な改善を示しています。

![最適化後の検索操作のベンチマーク結果](/images/opensearch-security-layer-perf-opt/benchmark-search-optimized.svg)

再び、紫の線はアクティブなドキュメントレベルセキュリティ制限を持つユーザーを表しています。最適化されたバージョンでは、ドキュメントレベルセキュリティ制限の有無によるパフォーマンス特性の違いが実質的にないことがわかります。そして、古いコードと比較すると、その改善は印象的です。わずか 100 インデックスのクラスターで、新しい実装はドキュメントレベルセキュリティ制限を持つユーザーのスループットを 58% 向上させています。

最も良いニュースは、ドキュメントレベルおよびフィールドレベルセキュリティの最適化された権限評価コードは、OpenSearch 3.0 でリリースされたため、すでに利用可能であることです。

## ユーザーオブジェクトの最適化

権限評価を最適化した後、セキュリティレイヤーのもう 1 つの中心的なコンポーネントであるユーザーオブジェクトに注目しました。興味深いことに、OpenSearch のパフォーマンスはユーザーオブジェクトのサイズにも依存する可能性があります。ユーザーオブジェクトのサイズは、主にユーザーに割り当てられたロールの数とユーザー属性の数に依存します。多くの場合、ロールと属性は非常に少ないですが、驚くべきケースもあります。特に LDAP を使用する環境では、ユーザーは多数のロールと属性を持つことがあります。

大きなユーザーオブジェクトによって強く影響を受けるプロセスの 1 つは、ノード間通信中のユーザーオブジェクトの交換です。これは特に、ユーザーデータの必要なシリアライゼーションとデシリアライゼーションによって引き起こされます。[イミュータブルユーザーオブジェクトプロジェクト](https://github.com/opensearch-project/security/pull/5212)を通じて、これらのプロセスを最小化することを目指しました。ユーザーオブジェクトをイミュータブルにすることで、シリアライズされた形式を定期的に再利用する可能性が得られ、必要なシリアライゼーションの回数が減少しました。キャッシュはデシリアライゼーションプロセスの回数を減らすのに役立ちます。

これらの最適化についても[ベンチマーク](https://github.com/opensearch-project/security/pull/5212#issuecomment-2804401414)を実行しました。改善は最適化された権限評価ほど大きくはありませんが、それでも良い結果を達成しました。

![ユーザーオブジェクト最適化後の検索操作のベンチマーク結果](/images/opensearch-security-layer-perf-opt/benchmark-search-user-object.svg)

ここでは、20 インデックスでの検索操作のスループットを確認できます。再び、破線は古いバージョンを表し、実線は最適化されたバージョンを表しています。横軸はユーザー属性の数、つまりユーザーオブジェクトのサイズを表しています。10 の属性を持つユーザーは 21% の改善を達成していることがわかります。100 の属性を持つユーザーは、古いバージョンを使用した場合よりも 39% 高いスループットを達成しています。

ユーザーオブジェクトの最適化は、最近 OpenSearch 3.1 でリリースされました。

## 改善されたインデックス解決

現在、セキュリティレイヤーのさらに別の側面に取り組んでいます。[インデックスパターン解決の改善プロジェクト](https://github.com/opensearch-project/security/issues/5367)を通じて、アクションリクエストがアクセスしようとしているインデックスをセキュリティレイヤーに伝えるコードに取り組んでいます。これにより、さらなるパフォーマンス向上が得られると考えています。

## まとめ

最新の OpenSearch バージョンには、セキュリティレイヤーに対する大幅なパフォーマンス改善が含まれています。特に多くのインデックスを持つクラスターがある場合、最新の OpenSearch バージョンにアップグレードすることで、より高いインデックス作成スループット、クエリレイテンシの削減、および全般的なクラスター CPU 使用率の削減が得られます。

結果は、インフラストラクチャの可能性を最大化するには、適切なアルゴリズムを備えた適切なデータ構造が必要であることを示しています。OpenSearch と Lucene には、特にインデックス作成と検索のコアにおいて、効率的なアルゴリズムとデータ構造の多くのアプリケーションが含まれています。

しかし、効率的でスケーラブルなコンポーネントを作成することは、特に分散システムでは困難な場合があります。OpenSearch Software Foundation の創設メンバーである [Eliatra](https://eliatra.com/) は、このような課題に対処するための深い専門知識とエンジニアリング能力を持っています。Eliatra のチームは、積極的にイノベーションを推進し、OpenSearch に本番グレードの改善を貢献しています。大規模な OpenSearch クラスターを運用していて、高度なチューニング、アーキテクチャガイダンス、またはカスタム機能が必要な場合は、Eliatra がお手伝いする準備ができています。

## リソース

- [Performance Improvements for the Access Control Layer of OpenSearch: An In-depth Technical Look – Part 1](https://eliatra.com/blog/performance-improvements-for-the-access-control-layer-of-opensearch/); [Part 2](https://eliatra.com/blog/performance-improvements-for-the-access-control-layer-of-opensearch-2/)
- [Issue: Optimized privilege evaluation](https://github.com/opensearch-project/security/issues/3870)
- [Issue: Make user object immutable](https://github.com/opensearch-project/security/issues/5168)
- [Issue: Index pattern resolution improvements](https://github.com/opensearch-project/security/issues/5367)
- [PR: Optimized privilege evaluation](https://github.com/opensearch-project/security/pull/4380)
- [PR: Immutable user object](https://github.com/opensearch-project/security/pull/5212)
