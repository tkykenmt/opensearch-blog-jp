---
title: "[翻訳] OpenSearch 2.7 で一般提供開始のセグメントレプリケーションでコンピューティングコストを削減しスループットを向上"
emoji: "🔄"
type: "tech"
topics: ["opensearch", "replication", "performance", "lucene", "indexing"]
published: true
publication_name: "opensearch"
published_at: 2023-05-04
---

:::message
本記事は [OpenSearch Project Blog](https://opensearch.org/blog/) に投稿された以下の記事を日本語に翻訳したものです。
:::

https://opensearch.org/blog/segment-replication/

セグメントレプリケーションの一般提供開始をお知らせします。これは Lucene の [Near-Real-Time (NRT) Segment Index Replication API](https://blog.mikemccandless.com/2017/09/lucenes-near-real-time-segment-index.html) 上に構築された新しいレプリケーション戦略で、OpenSearch 2.3 で実験的機能として導入され、[OpenSearch 2.7](https://opensearch.org/blog/get-started-opensearch-2-7-0/) で一般提供となりました。ドキュメントレプリケーションの代替として実装されたセグメントレプリケーションは、多くのユースケースでインデックススループットを大幅に向上させながらコンピューティングコストを削減します。ドキュメントレプリケーションでは、すべてのレプリカノード (*レプリカグループ* と呼ばれる) がプライマリノードと同じインデックス操作を実行します。セグメントレプリケーションでは、プライマリノードのみがインデックス操作を実行し、作成されたセグメントファイルがレプリカグループの各ノードにリモートコピーされます。このレプリケーション設計では、重いインデックスワークロードはプライマリノードでのみ実行され、レプリカのリソースが他の操作のスケールアウトに解放されます。本記事では、セグメントレプリケーションの概念、ドキュメントレプリケーションと比較した利点と欠点、および今後の機能強化について詳しく説明します。セグメントレプリケーションがユースケースに適しているかどうかを確認するには、[セグメントレプリケーションとドキュメントレプリケーション](#セグメントレプリケーションとドキュメントレプリケーション)を参照してください。

## コアコンセプト

OpenSearch でインデックスを作成する際、`number_of_shards` (デフォルトは 1) と呼ばれる *プライマリシャード* と `number_of_replicas` (デフォルトは 1) を指定します。各レプリカはプライマリシャードセットの完全なコピーです。5 つのプライマリシャードとそれぞれに 1 つのレプリカがある場合、クラスターには合計 10 個のシャードがあります。インデックス用に送信されたデータは、プライマリシャード間でランダムにハッシュされ、プライマリシャードによってレプリカにレプリケートされます。

内部的には、各シャードは [Lucene](https://lucene.apache.org/) インデックスのインスタンスです。Lucene はインデックス構造の読み書き用の Java ライブラリです。Lucene はファイルベースの追記専用検索 API です。*セグメント* は、ディスク上のフォルダ内の Lucene インデックスの一部です。インデックス用に送信された各ドキュメントはフィールドに分割され、フィールドのインデックスデータは 20〜30 の異なる構造に保存されます。Lucene はこれらの構造を RAM に保持し、最終的に *セグメント* と呼ばれるファイルのコレクションとしてディスクにフラッシュします。

レプリカは通常、耐久性とスケーラビリティの 2 つの目的で使用されます。レプリカシャードはクラスター内のデータの冗長な検索可能コピーを提供します。OpenSearch は、プライマリシャードとレプリカシャードのデータがクラスター内の異なるノードに割り当てられることを保証します。つまり、ノードを失ってもデータは失われません。OpenSearch は、障害のあるノードで失われた可能性のあるシャードの欠落コピーを自動的に再作成できます。クラウドで実行している場合、クラスターが分離されたデータセンター (AWS *アベイラビリティーゾーン*) にまたがっている場合、3 つのゾーンにわたって 2 つのレプリカを持つことで回復力を高めることができます。2 番目以降のレプリカは追加のクエリ容量を提供します。追加のレプリカとともにノードを追加して、クエリ処理のさらなる並列性を提供します。

## ドキュメントレプリケーション

バージョン 2.7 以前では、ドキュメントレプリケーションがデフォルトのレプリケーションモードです。このモードでは、インデックスに影響を与えるすべての書き込み操作 (ドキュメントの追加、更新、削除など) は、まずインデックスのプライマリシャードを含むノードにルーティングされます。プライマリシャードは操作を検証し、その後ローカルで実行する責任があります。操作が正常に完了すると、操作はレプリカグループの各ノードに並行して転送されます。グループ内の各レプリカノードは同じ操作を実行し、プライマリで実行された処理を複製します。操作がレプリカで完了すると (成功または失敗)、プライマリに応答が送信されます。グループ内のすべてのレプリカが応答すると、プライマリノードはコーディネーティングノードに応答し、コーディネーティングノードはレプリケーションの成功または失敗に関する詳細情報 (失敗した可能性のあるレプリカノードの数と種類など) を含む応答をクライアントに送信します。

ドキュメントレプリケーションの利点は、ドキュメントがプライマリシャードでの取り込み直後にレプリカに送信されるため、レプリカでドキュメントがより速く検索可能になることです。システムはプライマリシャードとレプリカシャード間で可能な限り迅速に一貫した状態に達します。ただし、ドキュメントレプリケーションは、すべてのドキュメントに対してすべてのプライマリとレプリカでインデックス操作が複製されるため、より多くの CPU を消費します。

以下の図にドキュメントレプリケーションのプロセスを示します。

![ドキュメントレプリケーションのプロセス](/images/opensearch-segment-replication/document-replication.png)

## セグメントレプリケーション

セグメントレプリケーションでは、ドキュメントはプライマリシャードを含むノードでのみインデックスされます。結果として得られるセグメントファイルは、グループ内のすべてのレプリカに直接コピーされ、検索可能になります。セグメントレプリケーションは、CPU 作業をプライマリノードでのみ実行することで、ドキュメントの追加、更新、削除のコンピューティングコストを削減します。基盤となる Lucene の追記専用インデックスにより、セグメントのコピーが可能になります。ドキュメントが追加、更新、削除されると、Lucene は新しいセグメントを作成しますが、既存のセグメントは変更されません (削除はソフト削除で、トゥームストーンと docvalue フィールドで処理されます)。

セグメントレプリケーションの利点は、ドキュメント内のデータの解析と処理の重複作業を排除することで、クラスター全体の CPU 使用率を削減することです。ただし、すべてのインデックスとネットワーキングがプライマリシャードを持つノードで発生するため、それらのノードはより重い負荷がかかります。さらに、プライマリシャードを持つノードはセグメント作成を待機し (`refresh_interval` で制御される時間)、セグメントをレプリカに送信するため、特定のドキュメントがすべてのシャードで一貫して検索可能になるまでの時間が増加します。

以下の図はセグメントレプリケーションのプロセスを示しています。

![セグメントレプリケーションのプロセス](/images/opensearch-segment-replication/segment-replication.png)

## セグメントレプリケーションのテスト結果

`stackoverflow` データセットを使用した 10 プライマリシャードと 1 レプリカでのベンチマーク取り込みテストでは、セグメントレプリケーションはドキュメントレプリケーションと比較して最大 25% の取り込みレートスループット向上を提供しました。詳細なベンチマーク結果については、[ベンチマーク](#ベンチマーク)セクションを参照してください。

実験的リリースのユーザーからは、同じクラスター設定でドキュメントレプリケーションよりもセグメントレプリケーションで最大 40% 高いスループットが報告されました。セグメントレプリケーションを使用すると、ドキュメントレプリケーションで 15 ノードで得られるのと同じ取り込みスループットを 9 ノードのクラスターで得ることができます。

## トレードオフの理解

セグメントレプリケーションは CPU 使用率を時間とネットワーキングと交換します。プライマリシャードはより大きなデータブロックをより低い頻度でレプリカに送信します。レプリカ数が増加すると、プライマリシャードがボトルネックになり、すべてのインデックス作業を実行し、すべてのセグメントをレプリケートします。テストでは、レプリカ数が 1 の場合に一貫した改善が見られました。レプリカ数が増加すると、改善は線形に減少します。クラスターでのパフォーマンス改善は、ワークロード、インスタンスタイプ、構成によって異なります。ワークロードに対するメリットを判断するために、独自のデータとクエリでセグメントレプリケーションをテストしてください。

より高いレプリカ数の場合、リモートストレージ統合がより効果的です。リモートストレージ統合では、プライマリシャードが Amazon Simple Storage Service (Amazon S3)、Google Cloud Storage、Azure Blob Storage などのオブジェクトストアにセグメントを書き込みます。レプリカはオブジェクトストアからセグメントを並行してロードし、プライマリシャードを持つノードがすべてのレプリカに大きなデータブロックを送信する必要がなくなります。リモートストレージ統合は将来のリリースで導入予定です。

分散システムと同様に、一部のクラスターノードは許容可能または予想されるスループットレベルに遅れる可能性があります。ローカル検索負荷の高さやネットワーク輻輳など、さまざまな理由でノードがプライマリノードに追いつけない場合があります。セグメントレプリケーションのパフォーマンスを監視するには、[OpenSearch benchmark](https://github.com/opensearch-project/opensearch-benchmark) を参照してください。

## セグメントレプリケーションとドキュメントレプリケーション

**セグメントレプリケーション** は以下の構成に最適です。

* クラスターデプロイメントのレプリカ数が少ない (1〜2 レプリカ)。これは通常、ログ分析デプロイメントに当てはまります。
* デプロイメントの取り込みレートが高く、検索ボリュームが比較的低い。
* アプリケーションがレプリケーションラグに敏感でない。
* ノード間のネットワーク帯域幅が、セグメントレプリケーションに必要な大量のデータ転送に十分である。

以下のユースケースでは、セグメントレプリケーションがうまく機能しないため、**ドキュメントレプリケーション** を推奨します。

* クラスターデプロイメントのレプリカ数が多い (3 以上) で、低いレプリケーションラグを重視する。これは通常、検索デプロイメントに当てはまります。
* デプロイメントがレプリケーションラグを許容できない。すべてのレプリカ間のデータ一貫性が重要な検索デプロイメントなどでは、高いレイテンシのためセグメントレプリケーションは推奨されません。
* デプロイメントのネットワーク帯域幅が、レプリカ数に対する迅速なデータ転送に不十分である。

クラスター全体のレプリケーションラグは [CAT Segment Replication API](https://opensearch.org/docs/latest/api-reference/cat/cat-segment-replication/) で検証できます。

ベンチマークテスト結果については、[ベンチマーク](#ベンチマーク)セクションを参照してください。

## セグメントレプリケーションバックプレッシャー

既存の[シャードインデックスバックプレッシャー](https://opensearch.org/docs/latest/tuning-your-cluster/availability-and-recovery/shard-indexing-backpressure/)に加えて、OpenSearch 2.7 ではデフォルトで無効になっている新しい[セグメントレプリケーションバックプレッシャー](https://opensearch.org/docs/latest/tuning-your-cluster/availability-and-recovery/segment-replication/backpressure/)リジェクションメカニズムが導入されました。

シャードインデックスバックプレッシャーは、クラスターに負荷がかかっているときにインデックスリクエストを動的にリジェクトするシャードレベルのスマートリジェクションメカニズムです。過負荷のノードまたはシャードからまだ正常な他のノードまたはシャードにリクエストを転送します。

セグメントレプリケーションバックプレッシャーは、レプリカがプライマリシャードに遅れていないことを監視します。レプリカが設定された時間制限内にプライマリシャードに同期していない場合、プライマリシャードはインデックスを遅くするために新しいドキュメントの取り込み時にリクエストのリジェクトを開始します。

## セグメントレプリケーションの有効化

インデックスでセグメントレプリケーションを有効にするには、ドキュメントの[ステップバイステップの手順](https://opensearch.org/docs/latest/tuning-your-cluster/availability-and-recovery/segment-replication/index/#segment-replication-configuration)に従ってください。

## ベンチマーク

以下のベンチマークは、[`stackoverflow`](https://www.kaggle.com/datasets/stackoverflow/stackoverflow) および [`nyc_taxi`](https://github.com/topics/nyc-taxi-dataset) データセットを使用して [OpenSearch-benchmark](https://github.com/opensearch-project/opensearch-benchmark) で収集されました。

ベンチマークは、以下の構成がセグメントレプリケーションに与える影響を示しています。

* ワークロードサイズ
* プライマリシャード数
* レプリカ数

**注意**: 結果はクラスタートポロジ、使用するハードウェア、シャード数、マージ設定によって異なる場合があります。

### ワークロードサイズの増加

以下の表は、`nyc_taxi` データセットのベンチマーク結果を示しています。

構成:
* 10 m5.xlarge データノード
* 40 プライマリシャード、各 1 レプリカ (合計 80 シャード)
* ノードあたり 4 プライマリシャードと 4 レプリカシャード

| | 40 GB プライマリシャード | | 240 GB プライマリシャード | |
|---|---|---|---|---|
| | ドキュメントレプリケーション | セグメントレプリケーション | ドキュメントレプリケーション | セグメントレプリケーション |
| インデックススループット (最小) | 148,134 | 185,092 (+24.95%) | 100,140 | 168,335 (+68.10%) |
| インデックススループット (中央値) | 160,110 | 189,799 (+18.54%) | 106,642 | 170,573 (+59.95%) |
| インデックススループット (最大) | 175,196 | 190,757 (+8.88%) | 108,583 | 172,507 (+58.87%) |

ワークロードサイズが増加すると、レプリカがより大きなデータセットをインデックスする必要がないため、セグメントレプリケーションのメリットが増幅されます。一般的に、セグメントレプリケーションは、レプリケーションラグを考慮しなければ、すべてのクラスター構成でドキュメントレプリケーションよりも低いリソースコストで高いスループットをもたらします。

### プライマリシャード数の増加

以下の表は、`nyc_taxi` データセットの 40 および 100 プライマリシャードのベンチマーク結果を示しています。

| | 40 プライマリシャード、1 レプリカ | | 100 プライマリシャード、1 レプリカ | |
|---|---|---|---|---|
| | ドキュメントレプリケーション | セグメントレプリケーション | ドキュメントレプリケーション | セグメントレプリケーション |
| インデックススループット (最小) | 148,134 | 185,092 (+24.95%) | 151,404 | 167,391 (+9.55%) |
| インデックススループット (中央値) | 160,110 | 189,799 (+18.54%) | 154,796 | 172,995 (+10.52%) |
| インデックススループット (最大) | 175,196 | 190,757 (+8.88%) | 166,173 | 174,655 (+4.86%) |

プライマリシャード数が増加すると、ドキュメントレプリケーションに対するセグメントレプリケーションのメリットは減少します。セグメントレプリケーションはより多くのプライマリシャードでも有益ですが、ノードあたりのプライマリシャードが増えてクラスター全体にセグメントファイルをコピーする必要があるため、パフォーマンスの差は小さくなります。

### レプリカ数の増加

以下の表は、`stackoverflow` データセットの 1 および 9 レプリカのベンチマーク結果を示しています。

| | 10 プライマリシャード、1 レプリカ | | 10 プライマリシャード、9 レプリカ | |
|---|---|---|---|---|
| | ドキュメントレプリケーション | セグメントレプリケーション | ドキュメントレプリケーション | セグメントレプリケーション |
| インデックススループット (中央値) | 72,598.10 | 90,776.10 (+25.04%) | 16,537.00 | 14,429.80 (−12.74%) |
| インデックススループット (最大) | 86,130.80 | 96,471.00 (+12.01%) | 21,472.40 | 38,235.00 (+78.07%) |
| CPU 使用率 (p50) | 17% | 18.857% | 69.857% | 8.833% (−87.36%) |
| メモリ使用率 (p50) | 35% | 23% (−34.29%) | 42% | 40% (−4.76%) |
| エラー率 | 0.00% | 0.00% | 0.00% | 2.30% |

レプリカ数が増加すると、プライマリシャードがレプリカを最新の状態に保つために必要な時間 (*レプリケーションラグ* と呼ばれる) も増加します。これは、セグメントレプリケーションがプライマリシャードからレプリカにセグメントファイルを直接コピーするためです。

ベンチマーク結果は、レプリカ数が増加するとゼロ以外のエラー率を示しています。エラー率は、レプリカがプライマリシャードに追いつけない場合に[セグメントレプリケーションバックプレッシャー](#セグメントレプリケーションバックプレッシャー)メカニズムが開始されることを示しています。ただし、エラー率はセグメントレプリケーションが提供する大幅な CPU とメモリの削減によって相殺されます。

## その他の考慮事項

2.7 リリースのセグメントレプリケーションには以下の考慮事項が適用されます。

* **Read-after-write 保証:** `wait_until` リフレッシュポリシーはセグメントレプリケーションと互換性がありません。ドキュメントの取り込み中に `wait_until` リフレッシュポリシーを使用すると、プライマリノードがリフレッシュしてそれらのドキュメントを検索可能にした後にのみ応答を受け取ります。レプリカシャードはローカル translog に書き込んだ後にのみ応答します。Read-after-write 保証を提供する他のメカニズムを検討しています。詳細については、対応する [GitHub issue](https://github.com/opensearch-project/OpenSearch/issues/6046) を参照してください。
* **システムインデックス** は、read-after-write 保証が利用可能になるまで内部的にドキュメントレプリケーションを使用し続けます。この場合、システムインデックスが少ないため、ドキュメントレプリケーションは全体的なパフォーマンスを妨げません。
* [既存のインデックスでセグメントレプリケーションを有効にする](https://github.com/opensearch-project/OpenSearch/issues/3685)には**再インデックス**が必要です。
* **ローリングアップグレード**はまだサポートされていません。新しいバージョンの OpenSearch へのアップグレードには、完全なクラスター再起動が必要です。

## 今後の予定

OpenSearch 2.7 リリースでは、セグメントレプリケーションのピアツーピア (ノード間) 実装が提供されます。このリリースでは、クラスター構成とワークロードに基づいて、ドキュメントレプリケーションまたはセグメントレプリケーションのいずれかを選択できます。今後のリリースでは、OpenSearch リモートストレージ (次世代ストレージアーキテクチャ) が単一のレプリケーションメカニズムとしてセグメントレプリケーションを使用します。セグメントレプリケーション対応のリモートストレージは、より高いレプリカ数のクラスターでプライマリシャードのネットワークボトルネックを解消します。プライマリシャードの負荷をさらに軽減するためのチェーンレプリケーション戦略も検討しています。使いやすさの向上のために、セグメントレプリケーションを OpenSearch Dashboards と統合し、Dashboards UI を使用して機能を有効にできるようにする予定です。また、ダウンタイムなしで新しいバージョンに移行しやすくするために、ローリングアップグレードの迅速なサポートを提供する予定です。
