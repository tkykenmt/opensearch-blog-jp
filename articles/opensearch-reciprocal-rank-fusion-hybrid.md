---
title: "[翻訳] ハイブリッド検索における Reciprocal Rank Fusion の導入"
emoji: "🔀"
type: "tech"
topics: ["opensearch", "hybridsearch", "search", "machinelearning", "relevance"]
published: true
published_at: 2025-02-12
publication_name: "opensearch"
---

:::message
本記事は [OpenSearch Project Blog](https://opensearch.org/blog/) に投稿された以下の記事を日本語に翻訳したものです。
:::

https://opensearch.org/blog/introducing-reciprocal-rank-fusion-hybrid-search/

OpenSearch 2.19 では、Neural Search プラグインの新機能として Reciprocal Rank Fusion (RRF) が導入され、ハイブリッド検索が強化されました。RRF は、ニューラル検索、k-NN、Boolean クエリなど、複数のクエリソースからのランク付けされた結果を、関連性が最適化された単一のリストにマージします。異なるソース間で一貫して上位にランクされるドキュメントを優先することで、RRF は従来のスコア正規化技術に依存せずに検索の関連性を向上させます。

## なぜハイブリッド検索に RRF を使用するのか？

RRF は、多様なクエリ方法からのランク付けされた結果を集約するのに特に有用です。スコアを共有スケールに調整する min-max や L2 正規化などの従来の正規化技術とは異なり、RRF はランクベースの集約戦略を使用します。このアプローチは、スコアベースの方法に比べて以下の利点を提供し、ハイブリッド検索の安定性と関連性を向上させます。

### さまざまなスコア分布に対する安定性

min-max などの従来の正規化技術は、異なるクエリ方法からのスコアを標準化されたスケールに収まるように調整します。しかし、異なるクエリ方法からの結果をマージする際、スコア分布の変動により不均衡なランキングが生じる可能性があります。ある方法のスコアリングパターンが支配的になり、検索品質が低下する可能性があります。L2 正規化はスコアを比例的にスケーリングしますが、個々のクエリ内のスコア分布の影響を受けます。RRF はランク位置のみに焦点を当てることでこれらの問題を回避し、異なるデータソース間で結果を一貫して扱うことを保証します。

### 外れ値への耐性

min-max と L2 正規化は外れ値に敏感であり、極端なスコアが最終ランキングに不釣り合いな影響を与える可能性があります。RRF はスコアではなくランキングを集約するため、異常値が関連性を歪めることを防ぎます。

### 関連性ランキングの一貫性

L2 正規化はスコアを共通のスケールに揃えますが、複数のクエリにまたがって表示されるドキュメントを優先するメカニズムがありません。RRF は、多様なクエリ方法で上位にランクされるアイテムを優先することでこれに優れており、より信頼性の高い関連性ランキングを保証します。

## RRF の実用的なアプリケーション

RRF は、データセットが特定の課題を提示する検索シナリオで特に効果的です。

### クエリ方法間のスコア変動への対処

BM25、ニューラル検索、k-NN などの異なる検索方法は、互換性のないスケールでスコアを生成します。L2 や min-max 正規化などの技術はこれらのスコアを標準化しようとしますが、最適でないランキングにつながる可能性があります。RRF は、絶対的なスコアの整合ではなくランクの一貫性を重視することで、この問題を回避します。

**例**: テキストベースのクエリが広範囲のスコアを生成し、視覚的特徴がより狭い範囲を生成するマルチモーダル検索パイプラインでは、RRF は小さなスケールの信号が埋もれないようにします。

### スパースな行動シグナルを持つ e コマース検索の強化

e コマースデータセットには、ユーザーのクリックや購入などのスパースな行動シグナルが含まれていることが多く、検索ランキングに組み込むのが困難な場合があります。ランクベースの集約は、エンゲージメントデータが限られている場合でも、関連性の高い製品を強調するのに役立ちます。

**例**: 行動データとメタデータをマージする際、RRF は高いセマンティックまたはメタデータの関連性を持つニッチな製品が表示されるようにします。一方、min-max と L2 正規化はスパースなシグナルに苦労する可能性があります。

### ノイズの多いデータや外れ値が発生しやすいデータの管理

科学研究やログデータなど、高い分散や頻繁な外れ値を持つデータセットは、min-max や L2 などのスコアベースの方法に課題をもたらします。RRF はスコアではなくランクに焦点を当てることで、外れ値が検索結果を歪めることを防ぎます。

**例**: 科学データセットでは、トップティアジャーナルからのメタデータがスコアを歪めることがよくあります。RRF は外れ値を過度に強調することなくこれらの結果を統合し、よりバランスの取れたランキングにつながります。

### 動的または進化するデータのサポート

ストリーミングログなどの急速に変化するデータセットでは、L2 と min-max 正規化の頻繁な再キャリブレーションが必要であり、不安定性やレイテンシが発生する可能性があります。RRF は静的なランク位置に基づいて集約することで、安定したランキングを維持します。

**例**: ログ検索パイプラインでは、スコア分布が時間とともに変化しても、RRF は頻繁に発生するパターンを一貫して優先します。

## RRF とスコアベースの方法の比較

以下の表は、同じクエリを使用した 2 つのハイブリッド検索アプローチを比較しています。標準的なハイブリッド検索パイプラインと RRF ベースのハイブリッド検索パイプラインです。比較のために上位 3 件と下位 3 件の結果を選択しました。RRF は、生のスコアではなく各クエリ結果内のドキュメントの相対的なランク (位置) に基づいてランク付けするため、ドキュメント間でより一貫したスコアを提供することに注目してください。

| `min_max` と `arithmetic_mean` | RRF |
| --- | --- |
| 0.5 | 0.01639 |
| 0.29481 | 0.01613 |
| 0.28132 | 0.01587 |
| 0.01396 | 0.01471 |
| 0.00386 | 0.01449 |
| 0.0005 | 0.01429 |

## RRF の仕組み

RRF は以下の手順でドキュメントをランク付けします。

1. **スコアでドキュメントをソート**: 各クエリ方法は、各シャードでスコアによってドキュメントをソートします。

![初期シャードスコア](/images/opensearch-reciprocal-rank-fusion-hybrid/RRFInitialShardScores-1024x265.png)

2. **ランク位置を割り当て**: ドキュメントは各クエリのスコアに基づいてランク付けされます。

![クエリドキュメントランキング](/images/opensearch-reciprocal-rank-fusion-hybrid/RRFQueryDocRankings.png)

3. **RRF 式を適用**: RRF スコアは以下の式を使用して計算されます。

```
rankScore(document_i) = sum((1/(k + query_1_rank), (1/(k + query_2_rank), ..., (1/(k + query_j_rank)))
```

この式で、`k` はランク定数であり、`query_j_rank` は特定のクエリ方法におけるドキュメントのランキングを表します。以下の図の例では、デフォルトのランク定数 60 を使用してこの式を適用しています。

![RRF 正規化](/images/opensearch-reciprocal-rank-fusion-hybrid/RRFNormalization.png)

4. **ランク寄与を加算**: ランク計算が結合され、ドキュメントはランクスコアの降順でソートされます。

![RRF 最終スコア計算](/images/opensearch-reciprocal-rank-fusion-hybrid/RRFFinalScoreCalculations.png)

5. **上位結果を返す**: クエリサイズに基づいて最高ランクのドキュメントが取得されます。

## RRF の使用方法

RRF を使用するには、検索パイプラインを作成し、`technique` として `rrf` を指定します。

```json
PUT /_search/pipeline/rrf-pipeline
{
  "description": "Post processor for hybrid RRF search",
  "phase_results_processors": [
    {
      "score-ranker-processor": {
        "combination": {
          "technique": "rrf"
        }
      }
    }
  ]
}
```

パイプラインの一部としてランク定数を指定することもできます。ランク定数は `1` 以上である必要があります。ランク定数が大きいほどスコアがより均一になり、上位ランクのアイテムの影響が減少します。ランク定数が小さいほどランク間の差がより急になり、上位ランクのアイテムにより多くの重みが与えられます。デフォルトでは、ランク定数は `60` に設定されています。

```json
PUT /_search/pipeline/rrf-pipeline
{
  "description": "Post processor for hybrid RRF search",
  "phase_results_processors": [
    {
      "score-ranker-processor": {
        "combination": {
          "technique": "rrf",
          "rank_constant": 40
        }
      }
    }
  ]
}
```

次に、ハイブリッドクエリを作成し、パイプラインを適用します。

```json
POST my_index/_search?search_pipeline=rrf-pipeline
{
   "query": {
     "hybrid": [
         {}, // 最初のクエリ
         {}, // 2 番目のクエリ
         ... // その他のクエリ
     ] 
   }
}
```

## RRF パフォーマンスのベンチマーク

ベンチマーク実験は、コーディネーターノードとして単一の r6g.8xlarge インスタンスと、データノードとして 3 つの r6g.8xlarge インスタンスで構成される OpenSearch クラスターを使用して実施されました。RRF のパフォーマンスを包括的に評価するために、6 つの異なるデータセットで 3 つの主要なメトリクスを測定しました。使用したデータセットについては、[Datasets](https://public.ukp.informatik.tu-darmstadt.de/thakur/BEIR/datasets/) を参照してください。

検索の関連性は、業界標準の Normalized Discounted Cumulative Gain at rank 10 (NDCG@10) を使用して定量化しました。また、検索レイテンシ測定を使用してシステムパフォーマンスを追跡し、実験中のリソース消費を分析するために CPU 使用率を監視しました。この設定は、検索品質と運用効率の両方を評価するための強固な基盤を提供しました。

### NDCG@10

以下の表は、さまざまなデータセットに対する異なる検索方法 (BM25、Neural、Hybrid、Hybrid with RRF) の NDCG@10 スコアを比較しています。*差分率* 列は、Hybrid と Hybrid with RRF アプローチ間の相対的なパフォーマンス変化を示しています。

|  | BM25 | Neural | Hybrid | Hybrid with RRF | 差分率 |
| --- | --- | --- | --- | --- | --- |
| NFCorpus | 0.3065 | 0.2174 | 0.3076 | 0.2977 | 3.22% |
| ArguAna | 0.4258 | 0.4239 | 0.4507 | 0.4476 | 0.69% |
| FIQA | 0.2389 | 0.2004 | 0.2693 | 0.2474 | 8.13% |
| Trec-Covid | 0.6087 | 0.2718 | 0.5905 | 0.5877 | 0.47% |
| SciDocs | 0.155 | 0.1075 | 0.1602 | 0.1525 | 4.81% |
| Quora | 0.7424 | 0.8256 | 0.8452 | 0.796 | 5.82% |
|  |  |  |  | **平均:** | 3.86% |

### 検索レイテンシ

以下の表は、Hybrid と RRF アプローチの両方について、異なるパーセンタイル (p50、p90、p99) での検索レイテンシ測定値 (ミリ秒) を示しています。*差分率* 列は、これらの方法間の相対的なパフォーマンスへの影響を示しています。

|  | **p50** | | | **p90** | | | **p99** | | |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  | **Hybrid** | **RRF** | **差分率** | **Hybrid** | **RRF** | **差分率** | **Hybrid** | **RRF** | **差分率** |
| NFCorpus | 71 | 67.5 | 4.93% | 95 | 89.9 | 5.37% | 112.84 | 109.56 | 2.91% |
| ArguAna | 390.5 | 390 | 0.13% | 423.5 | 424 | -0.12% | 459.475 | 458.5 | 0.21% |
| FIQA | 109 | 105.25 | 3.44% | 139.65 | 137.5 | 1.54% | 165.76 | 160.79 | 3.00% |
| Trec-Covid | 165.5 | 159.75 | 3.47% | 209.5 | 203.6 | 2.82% | 240.73 | 237.78 | 1.23% |
| SciDocs | 103 | 103.5 | -0.49% | 126.5 | 126.05 | 0.36% | 156.02 | 159.015 | -1.92% |
| Quora | 167 | 170 | -1.80% | 209.5 | 212.55 | -1.46% | 264.5 | 266.51 | -0.76% |
|  |  | **平均:** | 1.62% |  | **平均:** | 1.42% |  | **平均:** | 0.78% |

### CPU 使用率

以下の表は、コーディネーターノードでの CPU 使用率測定値を示し、Hybrid と RRF アプローチを比較しています。*差分率* 列は、2 つの方法間の CPU 使用量の相対的な変化を示しています。

|  | Hybrid | RRF | 差分率 |
| --- | --- | --- | --- |
| NFCorpus | 0.783% | 0.838% | 0.055% |
| ArguAna | 0.844% | 0.853% | 0.008% |
| FIQA | 0.835% | 0.851% | 0.016% |
| Trec-Covid | 1.406% | 0.979% | -0.427% |
| SciDocs | 0.745% | 0.873% | 0.128% |
| Quora | 1.054% | 1.076% | 0.022% |
|  |  | **平均:** | -0.033% |

## 結論

ベンチマーク実験は、従来のハイブリッド検索アプローチと比較した RRF の以下の利点とトレードオフを強調しています。

* **検索品質** (6 つのデータセットで NDCG@10 を使用して測定):
  + RRF は従来のスコアベースの方法より 3.86% 低いスコア
* **レイテンシの改善**:
  + RRF は以下の表に示すように、従来の正規化技術を一貫して上回る

| レイテンシパーセンタイル | 改善率 |
| --- | --- |
| p50 | 1.62% |
| p90 | 1.42% |
| p99 | 0.78% |

* **リソース効率**:
  + コーディネーターノードでの同様の CPU 使用量
  + すべてのノードタイプでより効率的なリソース分散

RRF は従来のハイブリッド検索方法に対する魅力的な代替手段を提供し、検索品質への影響を最小限に抑えながら、パフォーマンスとリソース効率を向上させます。また、大幅なレイテンシ改善を提供するため、高スループットの検索アプリケーションに特に適しています。

## 今後の予定

ロードマップには、RRF に対するいくつかの重要な機能強化が含まれています。

* **カスタマイズ可能な重み**: スコアベースのランキング技術と同様の重みサポートを実装し、ランキングアルゴリズムをより細かく制御できるようにする予定です。詳細については、[この issue](https://github.com/opensearch-project/neural-search/issues/1152) を参照してください。
* **欠落アイテムのより良い処理**: 現在、欠落アイテムはデフォルトでスコア 0.0 になりますが、これはすべてのユースケースに最適ではない可能性があります。設定可能なデフォルト値、欠落アイテムに `max_rank + 1` を使用する、または計算で欠落アイテムを完全に無視するなど、欠落アイテムを処理するための複数のアプローチを検討しています。詳細については、[この issue](https://github.com/opensearch-project/neural-search/issues/1153) を参照してください。

また、RRF を超えて OpenSearch のハイブリッド検索機能を拡張するために、正規化フレームワークに以下の改善を計画しています。

* **Z スコア正規化**: 人気のある z スコア正規化技術を追加します。詳細については、[この pull request](https://github.com/opensearch-project/neural-search/pull/470) を参照してください。
* **カスタム正規化関数**: 独自の正規化ロジックを定義し、検索結果のランキングを微調整できるようにします。詳細については、[この issue](https://github.com/opensearch-project/neural-search/issues/994) を参照してください。

これらの改善により、信頼性が高く一貫したハイブリッド検索結果を確保しながら、検索結果のランキングをより細かく制御できるようになります。今後の情報にご期待ください！

## 参考文献

1. [[RFC] Design for Incorporating Reciprocal Rank Fusion into Neural Search](https://github.com/opensearch-project/neural-search/issues/865)
2. [BEIR benchmarking for Information Retrieval](https://github.com/beir-cellar/beir)
3. [Reciprocal Rank Fusion outperforms Condorcet and individual Rank Learning Methods](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf)
4. [Risk-Reward Trade-offs in Rank Fusion](https://rodgerbenham.github.io/bc17-adcs.pdf)
5. [The ABCs of semantic search in OpenSearch: Architectures, benchmarks, and combination strategies](https://opensearch.org/blog/semantic-science-benchmarks)
6. [Improve search relevance with hybrid search, generally available in OpenSearch 2.10](https://opensearch.org/blog/hybrid-search/)
7. [[RFC] High Level Approach and Design For Normalization and Score Combination](https://github.com/opensearch-project/neural-search/issues/126)
