---
title: "[翻訳] OpenSearch k-NN におけるマルチベクトルサポートの強化"
emoji: "🔍"
type: "tech"
topics: ["opensearch", "knn", "vectorsearch", "rag", "machinelearning"]
published: true
published_at: 2024-03-28
publication_name: "opensearch"
---

:::message
本記事は [OpenSearch Project Blog](https://opensearch.org/blog/) に投稿された以下の記事を日本語に翻訳したものです。
:::

https://opensearch.org/blog/enhanced-multi-vector-support-in-opensearch-knn/

OpenSearch 2.12 では、Faiss または Lucene エンジンで HNSW アルゴリズムを使用する k-NN インデックスが大幅に強化され、マルチベクトルサポートをインテリジェントに処理することで検索結果の多様性が向上しました。OpenSearch は Lucene エンジンの強化のために、Lucene の [Parent Block Join 実装](https://github.com/apache/lucene/pull/12434)を統合しています。この改善により、k-NN 検索時に同一ドキュメント内の重複ベクトルを効果的に排除し、より良い検索結果を実現します。

## なぜこれが重要なのか

大規模言語モデル (LLM) の台頭により、多くのユーザーが情報のインデックス作成、保存、検索にベクトルデータベースを活用しています。特に検索拡張生成 (RAG) システムの構築において顕著です。ベクトルデータベースはテキスト埋め込みモデルを使用してテキストを埋め込みベクトルに変換し、意味情報を保持します。しかし、モデルには埋め込み生成時に考慮できるトークン数に制限があるため、大きなドキュメントはチャンクに分割して単一ドキュメント内に複数の埋め込みとして保存する必要があります。マルチベクトルサポートがない場合、ドキュメントの各チャンクを個別のエンティティとして扱う必要があり、ユーザーがドキュメントとメタデータを分離しない限り、複数のチャンクにわたってドキュメントメタデータが重複してしまいます。このメタデータの重複は、ストレージとメモリのオーバーヘッドを大幅に増加させる可能性があります。さらに、ユーザーは検索時に複数のチャンクから単一のドキュメントのみを取得するためのマージ機構を独自に考案する必要があります。マルチベクトルサポートにより、大きなドキュメントの処理が簡素化され、これらの課題が軽減されます。

## 以前の制限事項

OpenSearch 2.12 より前のバージョンでは、ネストフィールドを使用した k-NN 検索に 2 つの制限がありました。

### 結果数の減少

以前のバージョンの OpenSearch では、指定した最近傍数 (k 値) でネストされた k-NN フィールドを検索すると、k 件未満のドキュメントしか返されないことがありました。これは、検索がドキュメントレベルではなく、ネストフィールドレベル (チャンクレベル) で動作していたためです。最悪の場合、k 個の最近傍がすべて単一ドキュメントに属するチャンクである可能性があり、検索結果として 1 件のドキュメントしか返されないことがありました。k 値を増やせばより多くのドキュメントを取得できますが、不要な検索オーバーヘッドが発生します。

例えば、ドキュメント 1、2、3 の 3 つのドキュメントがあり、それぞれがネストされた k-NN フィールドに 2 つのベクトルを含んでいるとします。ドキュメント 1 にはベクトル A と B、ドキュメント 2 にはベクトル C と F、ドキュメント 3 にはベクトル D と E が含まれています。最も近い 2 つのベクトルが A と B で、どちらもドキュメント 1 に属しているとします。ネストされた k-NN フィールドを検索すると、k 値を 2 に設定しても、以下の図に示すようにドキュメント 1 のみが返されます。

![マルチベクトル改善前の検索結果 (例1)](/images/opensearch-enhanced-multi-vector-knn-support/multi-vector-before-1.png)

### 低い再現率

結果数の減少は、再現率の低下にもつながります。OpenSearch では、インデックスは複数のシャードで構成され、各シャードには複数のセグメントが含まれます。検索はセグメントレベルで実行され、結果はシャードレベルで集約されます。その後、すべてのシャードからの結果が集約されてユーザーに返されます。そのため、単一のセグメントに上位 k 件のドキュメントがすべて含まれているにもかかわらず、k 件未満のドキュメントしか返されない場合、最終結果には k 件のドキュメントが含まれますが、真の上位 k 件を表していません。これは、検索アルゴリズムがセグメントレベルで動作するため、上位 k 件に含まれるべき他のセグメントの関連ドキュメントを見逃す可能性があるためです。

これを説明するために、以下の例を考えてみましょう。7 つのインデックス済みドキュメントがあり、それぞれ 1 つまたは 2 つのベクトルを含んでいるとします。ネストされたベクトルフィールドを検索する際、最も近いものから遠いものへのベクトルの順序が A、B、C、D、E、F、G、H、I、J であると仮定します。検索はセグメントレベルで行われ、k 値が 2 の場合、セグメント 1 からはドキュメント 1 のみが返されます。その結果、最終的な集約結果にはドキュメント 1 とドキュメント 3 が含まれますが、期待される結果はドキュメント 1 とドキュメント 2 であるべきです。以下の図に示します。

![マルチベクトル改善前の検索結果 (例2)](/images/opensearch-enhanced-multi-vector-knn-support/multi-vector-before-2.png)

## OpenSearch 2.12 での改善

バージョン 2.12 では、OpenSearch はドキュメントとベクトルのマッピングデータを使用して検索結果の重複を排除します。このプロセスは、同一ドキュメントに属するベクトルが検索キューに既に収集されている場合に発生します。重複排除時、OpenSearch は各ドキュメントについてクエリベクトルに最も近いベクトルのみを保持します。選択されたベクトルの距離値は OpenSearch の検索スコアに変換され、最終的にドキュメントのスコアとなります。

以下の図を使って例を見てみましょう。ドキュメント 1 とドキュメント 2 の 2 つのドキュメントがあるとします。ドキュメント 1 にはベクトル A と B が、ドキュメント 2 にはベクトル C と D が含まれています (図 1)。検索中、ベクトル A が見つかり検索キューに追加されます (図 2)。次にベクトル B が見つかります。ベクトル A と B は両方ともドキュメント 1 に属しているため、距離が比較されます。クエリベクトルとベクトル B の距離は 0.9 で、クエリベクトルとベクトル A の距離 (1.0) より小さいです。その結果、ベクトル A は検索キューから削除され、ベクトル B が追加されます (図 3)。

その後、ベクトル D が見つかります。ベクトル D はドキュメント 2 に属しており、そのベクトルは検索キューにないため、ベクトル D がキューに追加されます (図 4)。次にベクトル C が見つかります。ベクトル C はドキュメント 2 に属しており、そのベクトルは既に検索キューにあるため、クエリベクトルとベクトル C および D の距離が比較されます。クエリベクトルとベクトル D の距離 (1.1) はクエリベクトルとベクトル C の距離 (1.2) より小さいため、ベクトル D は検索キューに残ります (図 5)。

ドキュメント 1 とドキュメント 2 の両方が返され、それらのスコアはクエリベクトルと検索キューに収集されたベクトル間の距離に基づいて計算されます。

![マルチベクトル改善後の検索処理フロー](/images/opensearch-enhanced-multi-vector-knn-support/multi-vector-after-1.png)

これにより、k 値が 2 の場合でも、最も近い 2 つのベクトルが 1 つのドキュメントに属しているか複数のドキュメントに属しているかに関係なく、2 件のドキュメントが返されるようになりました。さらに、各セグメントが最も近い k 個のベクトルに属するドキュメントではなく、最も近い k 件のドキュメントを返すようになったため、再現率も向上しています。

## ネストフィールドを使用したマルチベクトルの保存方法

ネストフィールドを持つ k-NN インデックスの作成と検索のプロセスを見ていきましょう。

まず、インデックス設定で `knn` 値を `true` に設定して k-NN インデックスを作成します。また、ネストフィールド内で `type` を `knn_vector` に設定します。`knn_vector` のその他のパラメータは、通常の `knn_vector` タイプと同じです。

```json
PUT my-knn-index
{
  "settings": {
    "index": {
      "knn": true
    }
  },
  "mappings": {
    "properties": {
      "my_vectors": {
        "type": "nested",
        "properties": {
          "my_vector": {
            "type": "knn_vector",
            "dimension": 2,
            "method": {
              "name": "hnsw",
              "space_type": "l2",
              "engine": "faiss"
            }
          }
        }
      }
    }
  }
}
```

次に、データを挿入します。ネストフィールド内のデータエントリ数は固定されていません。各ドキュメントに異なる数のネストフィールドアイテムをインデックスできます。例えば、この例ではドキュメント 1 には 3 つのネストフィールドアイテムが、ドキュメント 2 には 2 つのネストフィールドアイテムが含まれています。

```json
PUT _bulk?refresh=true
{ "index": { "_index": "my-knn-index", "_id": "1" } }
{"my_vectors":[{"my_vector":[1,1]},{"my_vector":[2,2]},{"my_vector":[3,3]}]}
{ "index": { "_index": "my-knn-index", "_id": "2" } }
{"my_vectors":[{"my_vector":[10,10]},{"my_vector":[20,20]}]}
```

データを検索する際、クエリ構造が通常の k-NN 検索とは若干異なることに注意してください。クエリを指定したパスでネストクエリにラップします。また、フィールド名にはネストフィールド名と `knn_vector` フィールド名の両方をドットで区切って指定する必要があります (以下の例では `my_vectors.my_vector`)。

```json
GET my-knn-index/_search
{
  "query": {
    "nested": {
      "path": "my_vectors",
      "query": {
        "knn": {
          "my_vectors.my_vector": {
            "vector": [1,1],
            "k": 2
          }
        }
      }
    }
  }
}
```

k 値を 2 に指定すると、最も近い 3 つのベクトルがドキュメント 1 に属していても、1 件ではなく 2 件のドキュメントが取得されます。

```json
{
    "took": 1,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 2,
            "relation": "eq"
        },
        "max_score": 1.0,
        "hits": [
            {
                "_index": "my-knn-index",
                "_id": "1",
                "_score": 1.0,
                "_source": {
                    "my_vectors": [
                        {
                            "my_vector": [
                                1,
                                1
                            ]
                        },
                        {
                            "my_vector": [
                                2,
                                2
                            ]
                        },
                        {
                            "my_vector": [
                                3,
                                3
                            ]
                        }
                    ]
                }
            },
            {
                "_index": "my-knn-index",
                "_id": "2",
                "_score": 0.006134969,
                "_source": {
                    "my_vectors": [
                        {
                            "my_vector": [
                                10,
                                10
                            ]
                        },
                        {
                            "my_vector": [
                                20,
                                20
                            ]
                        }
                    ]
                }
            }
        ]
    }
}
```

## まとめ

OpenSearch 2.12 では、複数の最近傍ベクトルが少数のドキュメントにのみ属している場合でも、k-NN インデックスからより正確な検索結果を取得できるようになりました。これは、OpenSearch を競争力のあるベクトルデータベースとして確立するための重要な進歩です。inner hit サポート [[#1447](https://github.com/opensearch-project/k-NN/issues/1447)] や自動チャンキング [[#548](https://github.com/opensearch-project/neural-search/issues/548)] など、マルチベクトル機能をサポートする追加の機能強化が現在開発中です。これらの機能の実装を希望される場合は、対応する GitHub issue に投票してください。いつものように、OpenSearch k-NN 機能に関するその他のアイデアやリクエストがあれば、[k-NN リポジトリ](https://github.com/opensearch-project/k-NN)に新しい issue を自由に提出してください。
